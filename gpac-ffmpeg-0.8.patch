--- gpac/modules/ffmpeg_in/ffmpeg_decode.c.orig	2011-06-27 18:51:07.878588020 +0200
+++ gpac/modules/ffmpeg_in/ffmpeg_decode.c	2011-06-27 20:18:43.345430660 +0200
@@ -24,6 +24,7 @@
 
 #include "ffmpeg_in.h"
 #include <gpac/avparse.h>
+#include <libavutil/avutil.h>
 
 static AVCodec *ffmpeg_get_codec(u32 codec_4cc)
 {
@@ -111,7 +112,7 @@
 		bs = gf_bs_new(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_BITSTREAM_READ);
 		codec_id = gf_bs_read_u32(bs);
 		if (ffd->st==GF_STREAM_AUDIO) {
-			ffd->ctx->codec_type = CODEC_TYPE_AUDIO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_AUDIO;
 			ffd->ctx->sample_rate = gf_bs_read_u32(bs);
 			ffd->ctx->channels = gf_bs_read_u16(bs);
 			ffd->ctx->frame_size = gf_bs_read_u16(bs);
@@ -121,7 +122,7 @@
 			/*ffmpeg specific*/
 			ffd->ctx->block_align = gf_bs_read_u16(bs);
 		} else if (ffd->st==GF_STREAM_VISUAL) {
-			ffd->ctx->codec_type = CODEC_TYPE_VIDEO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_VIDEO;
 			ffd->ctx->width = gf_bs_read_u16(bs);
 			ffd->ctx->height = gf_bs_read_u16(bs);
 		}
@@ -138,7 +139,7 @@
 		bs = gf_bs_new(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_BITSTREAM_READ);
 		codec_id = gf_bs_read_u32(bs);
 		if (ffd->st==GF_STREAM_AUDIO) {
-			ffd->ctx->codec_type = CODEC_TYPE_AUDIO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_AUDIO;
 			ffd->ctx->sample_rate = gf_bs_read_u32(bs);
 			ffd->ctx->channels = gf_bs_read_u16(bs);
 			ffd->ctx->frame_size = gf_bs_read_u16(bs);
@@ -151,7 +152,7 @@
 			  ffd->ctx->frame_size = 160;
 			}
 		} else if (ffd->st==GF_STREAM_VISUAL) {
-			ffd->ctx->codec_type = CODEC_TYPE_VIDEO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_VIDEO;
 			ffd->ctx->width = gf_bs_read_u16(bs);
 			ffd->ctx->height = gf_bs_read_u16(bs);
 		}
@@ -163,7 +164,7 @@
 	else {
 		u32 codec_id = 0;
 		if (ffd->st==GF_STREAM_VISUAL) {
-			ffd->ctx->codec_type = CODEC_TYPE_VIDEO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_VIDEO;
 			switch (ffd->oti) {
 			case 0x20:
 				codec_id = CODEC_ID_MPEG4;
@@ -190,7 +191,7 @@
 				break;
 			}
 		} else if (ffd->st==GF_STREAM_AUDIO) {
-			ffd->ctx->codec_type = CODEC_TYPE_AUDIO;
+			ffd->ctx->codec_type = AVMEDIA_TYPE_AUDIO;
 			switch (ffd->oti) {
 			case 0x69:
 			case 0x6B:
@@ -412,20 +413,20 @@
 
 	/*WARNING: this breaks H264 (and maybe others) decoding, disabled for now*/
 #if 1
-	if (!ffd->ctx->hurry_up) {
+	if (ffd->ctx->skip_frame < AVDISCARD_NONREF) {
 		switch (mmlevel) {
 		case GF_CODEC_LEVEL_SEEK:
 		case GF_CODEC_LEVEL_DROP:
 			/*skip as much as possible*/
-			ffd->ctx->hurry_up = 5;
+			ffd->ctx->skip_frame = AVDISCARD_NONKEY;
 			break;
 		case GF_CODEC_LEVEL_VERY_LATE:
 		case GF_CODEC_LEVEL_LATE:
 			/*skip B-frames*/
-			ffd->ctx->hurry_up = 1;
+			ffd->ctx->skip_frame = AVDISCARD_NONREF;
 			break;
 		default:
-			ffd->ctx->hurry_up = 0;
+			ffd->ctx->skip_frame = AVDISCARD_DEFAULT;
 			break;
 		}
 	}
@@ -451,7 +452,7 @@
 		if (len<0) { ffd->frame_start = 0; return GF_NON_COMPLIANT_BITSTREAM; }
 		if (gotpic<0) { ffd->frame_start = 0; return GF_OK; }
 
-		ffd->ctx->hurry_up = 0;
+		ffd->ctx->skip_frame = AVDISCARD_DEFAULT;
 
 		if (ffd->ctx->frame_size < gotpic) ffd->ctx->frame_size = gotpic;
 
@@ -552,7 +553,7 @@
 				}
 			}
 		}
-		ffd->ctx->hurry_up = 0;
+		ffd->ctx->skip_frame = AVDISCARD_DEFAULT;
 		/*recompute outsize in case on-the-fly change*/
 		if ((w != ffd->ctx->width) || (h != ffd->ctx->height)) {
 			outsize = ffd->ctx->width * ffd->ctx->height * 3;
--- gpac/modules/ffmpeg_in/ffmpeg_demux.c.orig	2008-11-28 18:21:48.000000000 +0100
+++ gpac/modules/ffmpeg_in/ffmpeg_demux.c	2011-06-27 21:20:51.252222149 +0200
@@ -31,6 +31,7 @@
 #if !defined(WIN32) && !defined(_WIN32_WCE) && !defined(__SYMBIAN32__)
 #include <errno.h>
 #endif
+#include <libavutil/avutil.h>
 
 static u32 FFDemux_Run(void *par)
 {
@@ -233,10 +234,10 @@
     for(i = 0; i < ctx->nb_streams; i++) {
         AVCodecContext *enc = ctx->streams[i]->codec;
         switch(enc->codec_type) {
-        case CODEC_TYPE_AUDIO:
+        case AVMEDIA_TYPE_AUDIO:
             if (!has_audio) has_audio = 1;
             break;
-        case CODEC_TYPE_VIDEO:
+        case AVMEDIA_TYPE_VIDEO:
             if (!has_video) has_video= 1;
             break;
         default:
@@ -531,10 +532,10 @@
 
 	switch (i) {
 	case 0: e = GF_OK; break;
-	case AVERROR_IO: e = GF_URL_ERROR; goto err_exit;
+	case AVERROR(EIO): e = GF_URL_ERROR; goto err_exit;
 	case AVERROR_INVALIDDATA: e = GF_NON_COMPLIANT_BITSTREAM; goto err_exit;
-	case AVERROR_NOMEM: e = GF_OUT_OF_MEM; goto err_exit;
-	case AVERROR_NOFMT: e = GF_NOT_SUPPORTED; goto err_exit;
+	case AVERROR(ENOMEM): e = GF_OUT_OF_MEM; goto err_exit;
+	case AVERROR(EILSEQ): e = GF_NOT_SUPPORTED; goto err_exit;
 	default: e = GF_SERVICE_ERROR; goto err_exit;
 	}
 
@@ -552,13 +553,13 @@
     for (i = 0; i < ffd->ctx->nb_streams; i++) {
         AVCodecContext *enc = ffd->ctx->streams[i]->codec;
         switch(enc->codec_type) {
-        case CODEC_TYPE_AUDIO:
+        case AVMEDIA_TYPE_AUDIO:
             if ((ffd->audio_st<0) && (ffd->service_type!=1)) {
 				ffd->audio_st = i;
 				ffd->audio_tscale = ffd->ctx->streams[i]->time_base;
 			}
             break;
-        case CODEC_TYPE_VIDEO:
+        case AVMEDIA_TYPE_VIDEO:
             if ((ffd->video_st<0) && (ffd->service_type!=2)) {
 				ffd->video_st = i;
 				ffd->video_tscale = ffd->ctx->streams[i]->time_base;
